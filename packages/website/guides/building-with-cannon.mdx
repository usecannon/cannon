---
title: Building with Cannon
description: Learn how to build a package.
before:
  url: "creating-a-project"
  title: "Creating a project"
  description: "Learn how to create a project with Cannon."
after:
  url: "building-to-a-network"
  title: "Building to a network"
  description: "Learn how to take your package to production."
---

## Building with Cannon

First, what we need to do is to build the Cannon package. To do this we will use the `cannon build` command. This command will build a new package using the `cannonfile.toml`  we created later.

<Alert variant="warning" className="mt-6">
  <AlertDescription>
    âš ï¸ The `cannon build` uses the `cannonfile.toml` by default but you can specify which cannonfile you want to use with the `[cannonfile]` argument. You can find all the CLI commands documentation in the [CLI guide](https://usecannon.com/learn/cli).
  </AlertDescription>
</Alert>

Run in your terminal:

```solidity
// ./test/Counter.t.sol

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import { Test } from "forge-std/Test.sol";
import { Counter } from "../src/Counter.sol";

contract CounterTest is Test {
    Counter public counter;
    
    Counter counter

    function setUp() public {
        counter = new Counter();
        counter.setNumber(0);
    }

    function test_Increment() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

    function testFuzz_SetNumber(uint256 x) public {
        counter.setNumber(x);
        assertEq(counter.number(), x);
    }
```

If everything went well you will see something like this:

```bash
Building the foundry project...
forge build succeeded

Anvil instance running on: http://127.0.0.1:59576

Checking for existing package...
Starting fresh build...

Initializing new package...
Name: learn-cannon
Version: 0.0.1
Preset: main (default)
Chain ID: 13370

Building the chain (ID 13370) via http://127.0.0.1:59576/...

Executing [deploy.counter]...
  âœ” Successfully deployed Counter
  Contract Address: 0xACEbBC3E0D8BC1bB13a35b40f3714A7c78C158f7
  Transaction Hash: 0x0abfae8229490349f80230414259ca1fcc60eecead61212733154fb3c80feae1
  Transaction Cost: 0.000213466 ETH (106,733 gas)

Executing [var.main]...
  Setting: number = 420

Executing [invoke.set_number]...
  âœ” Successfully called setNumber(420)
  Signer: 0xEB045D78d273107348b0300c01D29B7552D622ab
  Contract Address: 0xACEbBC3E0D8BC1bB13a35b40f3714A7c78C158f7
  Transaction Hash: 0x4ceea742fecb9ba8adce1d364beb01f17dc93125b740e532bbdd8ff1068b96eb
  Transaction Cost: 0.00007268124780963 ETH (43,506 gas)

Writing upgrade info...
ğŸ’¥ learn-cannon:0.0.1@main built for Cannon (Chain ID: 13370)
This package can be run locally and cloned in cannonfiles.

Package data has been stored locally
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Deployment Data â”‚ ipfs://QmVpLGJMKqAd5hD3LgM3oh37NfbmzTS9FUyjCZx1LcB8yW â•‘
â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢
â•‘ Package Code    â”‚ ipfs://QmVhGysWPz2toaL9FVWoyTTgp2Atf4UMESz4Dj5dKvRhWb â•‘
â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢
â•‘ Metadata        â”‚ ipfs://QmRsYpSHrvjVmktXJtLYZbmiHD8GNKp64qxoZ2hbGcqEDf â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Publish learn-cannon:0.0.1 to the registry and pin the IPFS data to
> cannon publish learn-cannon:0.0.1 --chain-id 13370

Run this package
> cannon learn-cannon:0.0.1
```

<Alert variant="info" className="mt-4">
  <AlertDescription>
    ğŸ“¢ What Cannon does in this case is run the build on a local Anvil node, but the node is not kept running, resulting in a kind of "compilation". If you want to keep the node running, you can use the `--keep-alive` flag.
  </AlertDescription>
</Alert>

#### Deployment breakdown

First, let's try to understand what Cannon is doing with the `build` command.

As we can see, Cannon runs each of the steps we defined in the `cannonfile` previously, which is why Cannon is declarative.

By default, Cannon will build the package on a empty local chain with the id 13370. Later we will learn how to build using different chains IDs.

```bash
...
Building the chain (ID 13370) via http://127.0.0.1:59576/...
...
```

Once the build is done, the execution of the steps defined in the `cannonfile.toml` begins.

```bash
Executing [deploy.counter]...
  âœ” Successfully deployed Counter
  Contract Address: 0xACEbBC3E0D8BC1bB13a35b40f3714A7c78C158f7
  Transaction Hash: 0x0abfae8229490349f80230414259ca1fcc60eecead61212733154fb3c80feae1
  Transaction Cost: 0.000213466 ETH (106,733 gas)

Executing [var.main]...
  Setting: number = 420

Executing [invoke.set_number]...
  âœ” Successfully called setNumber(420)
  Signer: 0xEB045D78d273107348b0300c01D29B7552D622ab
  Contract Address: 0xACEbBC3E0D8BC1bB13a35b40f3714A7c78C158f7
  Transaction Hash: 0x4ceea742fecb9ba8adce1d364beb01f17dc93125b740e532bbdd8ff1068b96eb
  Transaction Cost: 0.00007268124780963 ETH (43,506 gas)
```

Once the build steps are completed, the CLI will notify you that everything went well and provide you with all the build data in IPFS URLs.

```bash
Writing upgrade info...
ğŸ’¥ learn-cannon:0.0.1@main built for Cannon (Chain ID: 13370)
This package can be run locally and cloned in cannonfiles.

Package data has been stored locally
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Deployment Data â”‚ ipfs://QmVpLGJMKqAd5hD3LgM3oh37NfbmzTS9FUyjCZx1LcB8yW â•‘
â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢
â•‘ Package Code    â”‚ ipfs://QmVhGysWPz2toaL9FVWoyTTgp2Atf4UMESz4Dj5dKvRhWb â•‘
â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢
â•‘ Metadata        â”‚ ipfs://QmRsYpSHrvjVmktXJtLYZbmiHD8GNKp64qxoZ2hbGcqEDf â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

**Deployment Data**

The deployment data contains the state of the package generated by the build.

**Package Code**

The package code contains the artifacts of the built contracts.

**Metadata**

Cannon stores relevant package information, such as GitHub PR URLs, which we then use throughout our ecosystem.

#### Running locally

To run your package locally, you can use the `cannon run` command. The `run` command takes the package name as an argument (`<packageRefs>`).

<Alert variant="info" className="mt-6">
  <AlertDescription>
    ğŸ“¢ The `cannon run` works with many optional arguments that we will not be covering in this example.  You can find all the CLI commands documentation in the [CLI guide](https://usecannon.com/learn/cli).
  </AlertDescription>
</Alert>

To run your package locally use:

```bash
$ cannon run learn-cannon:0.0.1
```

Cannon will create an Anvil node locally with the previously generated build, allowing you to interact with the contract we just created.

The result of running the `run` command should be something like this:

```bash
Starting local node...

Anvil instance running on: http://127.0.0.1:64228

learn-cannon:0.0.1@main has been deployed to a local node.

Press h to see help information for this command.
Press a to toggle displaying the logs from your local node.
Press i to interact with contracts via the command line.
Press v to toggle display verbosity of transaction traces as they run.**
```

As you can see, Cannon allows you to interact with your package in a simple way.

- Pressing the letter `h` will show you all the information about the `run` command.
- Pressing the letter `a` will allow you to see all the logs from your local node.

```bash
...
anvil:     Block Number: 3
anvil:     Block Hash: 0xc6ec0d6a72c8b026ba72887312a491efdca7edf57b7f93e76e93da7d725f7df3
anvil:     Block Time: "Thu, 10 Oct 2024 17:19:20 +0000"
...
```

- Pressing the letter `i` will allow you to interact with the contracts from the CLI. In this case, you will see the following:

```bash
================================================================================
> Gas price: provider default
> Block tag: latest
> Read/Write: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
> Signer Balance: 10000
================================================================================

? Pick a CONTRACT: â€º
â¯   â†© BACK
    counter
```

Here you will be able to see that the `counter` contract created previously appears. If you had created more contracts, they would also appear in this list.

Once the contract is selected, we will be able to interact with the functions defined in the smart contract. The CLI will allow us to pass arguments to functions that require them for their use, as well as invoke functions without arguments.

```bash
? Pick a FUNCTION: â€º
â¯   â†© BACK
    function increment()
    function number()
    function setNumber(uint256 newNumber)
```

In this case, we can see how the functions `number` or `increment` are functions that we can invoke and do not require arguments, unlike `setNumber` which does need an argument.

In this case, we can see the argument definition directly in the CLI.

In this case, we will invoke the `number()` function. The result of this function (as we defined in the contract) will be an `int` indicating the number stored in the contract.

```bash
// function number() output

âœ” Pick a FUNCTION: â€º function number()
  > calldata: 0x8381f58a
  > estimated gas required: 23347
  â†ª (uint256):  420
counter => 0xACEbBC3E0D8BC1bB13a35b40f3714A7c78C158f7
  * Signer: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
```

What the CLI is showing us here is the execution of the function and its result. Let's analyze it in parts:

- The `calldata` is the function selector itself. For advanced users, this can be useful for debugging among other things.
- We can see the **estimated gas required** for the function execution. This is very good for knowing if our function is efficient.
- The type and value of the data returned by the function. In this case, `420` is the value returned by the `number()` function.
- The address of the `counter` contract on the local node we set up.
- And finally, the wallet we are using as the signer.

- And last but not least, pressing the letter `v` will enable to display verbosity of transactions traces.

#### Testing our contract

By convention, tests in Foundry are located in the `/test` folder and the test files have `test` in their name, although `.t.sol` is usually used as the extension.

<Alert variant="warning" className="mt-6">
  <AlertDescription>
    âš ï¸ For more information on how to write and perform tests with Foundry, we suggest you review the testing guide at [book.getfoundry.sh/forge/tests](https://book.getfoundry.sh/forge/tests).
  </AlertDescription>
</Alert>

In this example, we will use the test created by `forge init`. It's an example test created for the `Counter.sol` contract, also created by Forge.

```solidity
// ./test/Counter.t.sol

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import { Test } from "forge-std/Test.sol";
import { Counter } from "../src/Counter.sol";

contract CounterTest is Test {
    Counter public counter;
    
    Counter counter

    function setUp() public {
        counter = new Counter();
        counter.setNumber(0);
    }

    function test_Increment() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

    function testFuzz_SetNumber(uint256 x) public {
        counter.setNumber(x);
        assertEq(counter.number(), x);
    }
}
```

We are going to use the `cannon-std` helper library from Cannon to write tests. This library allows us to interact with the previously generated build. Letâ€™s install it, run:

```bash
$ forge install usecannon/cannon-std
```

Cannon runs `forge test` in the background, but the `cannon test` command can receive a specific cannonfile as an argument to run the test suites. By default, it uses `cannonfile.toml`.

<Alert variant="warning">
  <AlertDescription>
    âš ï¸ This is a simple case of testing using `cannon test`. Later, we'll see how we can use `usecannon/cannon-std` to interact with the Cannon registry and other contracts deployed in Cannon.
  </AlertDescription>
</Alert>

After running the tests, the CLI will **notify** us that all tests have passed successfully.


```bash
Writing deployment artifacts to ./deployments/test
[â Š] Compiling...
No files changed, compilation skipped

Ran 2 tests for test/Counter.t.sol:CounterTest
[PASS] testFuzz_SetNumber(uint256) (runs: 256, Î¼: 31054, ~: 31288)
[PASS] test_Increment() (gas: 31303)
Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 19.96ms (11.97ms CPU time)

Ran 1 test suite in 135.12ms (19.96ms CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)
forge exited with code 0
```