---
title: Migration Guide
description: Tips for moving to cannon from another deployment framework
---

# Migration Guide

This guide helps you migrate from various deployment tools to Cannon. Each section covers a specific tool and provides step-by-step instructions.

## Table of Contents

- [From Hardhat Deploy](#from-hardhat-deploy)
- [From Custom Foundry Scripts](#from-custom-foundry-scripts)
- [From JSON File Dumps](#from-json-file-dumps)

## From Hardhat Deploy

### Overview
[Hardhat Deploy](https://www.npmjs.com/package/hardhat-deploy) uses a deployment system with tagged deployments and deployment functions. Cannon can import from these deployments once the equivalent Cannonfile has been created.

### Migration Steps

1. 

2. 

3. 

### Key Differences
- Cannon operates declarative deployments in TOML; Hardhat Deploy operates generally imperative deployments in JS/TS.
- Cannon writes deployment artifacts to a internal storage that can be deployed to IPFS and Onchain, separate from your repository; Hardhat Deploy writes JSON files directly to your repository.
- Cannon supports multi-chain deployments out of the box; Hardhat Deploy typically requires a new deployment configuration for every network.

## From Foundry Scripts

### Overview
[Foundry scripts](https://getfoundry.sh/guides/scripting-with-solidity/) are written in Solidity and can be used to execute deployments, among other things. Cannon import any deployed contracts or transactions previously executed once the declarative deployment configuration is created.

### Migration Steps

1. **Extract deployment logic**
   ```solidity
   // Original Foundry script
   contract DeployScript is Script {
       function run() external {
           vm.startBroadcast();
           Greeter greeter = new Greeter("Hello, Foundry!");
           vm.stopBroadcast();
       }
   }
   ```

2. **Create cannonfile.toml**
   ```toml
   [contract.greeter]
   source = "./src/Greeter.sol"
   
   [contract.greeter.deploy]
   args = ["Hello, Cannon!"]
   ```

3. **Convert constructor arguments**
   - Extract constructor parameters from your script
   - Convert them to TOML format in the cannonfile

### Key Differences
- Cannon operates declarative deployments in TOML; Hardhat Deploy operates generally imperative deployments in JS/TS.
- Cannon handles dependency management automatically, so ordering operations is not needed.
- Cannon writes deployment artifacts to a internal storage that can be deployed to IPFS and Onchain, separate from your repository; Hardhat Deploy writes JSON files directly to your repository.
- Cannon supports multi-chain deployments out of the box; Hardhat Deploy typically requires a new deployment configuration for every network.

## From Deployment Manifests/Other Deployment Tools

### Overview
Deployment manifests (JSON/YAML files) contain contract addresses and deployment metadata. Regardless of the format used, Cannon can import and use this data.

### Migration Steps

1. **Prepare your manifest file**
   ```json
   {
     "contracts": {
       "Greeter": {
         "address": "0x1234...",
         "constructorArgs": ["Hello, World!"],
         "deployedAt": "2024-01-01T00:00:00Z"
       }
     }
   }
   ```

2. **Import to Cannon**
   ```bash
   # Import the manifest
   cannon import manifest deployment.json
   ```

3. **Verify and build**
   ```bash
   # Build the cannonfile
   cannon build
   
   # Verify the deployment
   cannon verify
   ```

### Key Differences
- Cannon provides live deployment capabilities
- Cannon handles contract verification automatically
- Cannon supports complex deployment dependencies
