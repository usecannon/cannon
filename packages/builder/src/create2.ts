import Debug from 'debug';
import * as viem from 'viem';
import { CannonSigner, ChainBuilderRuntimeInfo } from './';

const debug = Debug('cannon:builder:create2');

export const ARACHNID_DEFAULT_DEPLOY_ADDR = '0x3fab184622dc19b6109349b94811493bf2a45362';

export const ARACHNID_DEPLOY_TXN =
  '0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222';

/**
 * If arachnid create2 proxy is not already deployed, this function can deploy it.
 * @param runtime the runtime which can be used to deploy
 */
export async function ensureArachnidCreate2Exists(
  runtime: ChainBuilderRuntimeInfo,
  deployer: viem.Address
): Promise<viem.Address> {
  // if arachnid create2 contract is not deployed
  const proxyAddress = viem.getCreateAddress({ from: deployer, nonce: BigInt(0) });
  const detectedBytecode = await runtime.provider.getBytecode({ address: proxyAddress });
  if (!detectedBytecode || detectedBytecode === '0x') {
    debug('arachnid create2 contract not found. attempting to deploy...');
    // on local testnets the arachnid contract is not deployed,
    // but we can deploy it easily

    // first "get" the signer (which will populate it for use and with enough eth for gas)
    // if signer doesn't exist then this isnt local testing network, and this txn will fail
    let signer: CannonSigner;
    try {
      signer = await runtime.getSigner(deployer);
    } catch (err) {
      debug('got arachnid signer error', err);
      throw new Error(
        'could not populate arachnid signer address. ' +
          'This most likely means you are trying to deploy to a non-local network, but the arachnid create2 contract has not been deployed. ' +
          'Please follow the instructions to deploy arachnid create2.'
      );
    }

    // now run the presigned deployment txn
    const hash = await signer.wallet.sendTransaction({
      account: signer.address,
      chain: runtime.provider.chain,
      data: '0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3',
    });

    await runtime.provider.waitForTransactionReceipt({ hash });
  }

  return proxyAddress;
}

/**
 * Returns the address generated by a CREATE2 call using the arachnid proxy
 */
export function makeArachnidCreate2Txn(
  salt: string,
  initcode: viem.Hex,
  arachnidAddress: viem.Address
): [Pick<viem.TransactionRequest, 'to' | 'data'>, viem.Address] {
  const saltHash: viem.Hash = !viem.isHash(salt) ? viem.keccak256(viem.toBytes(salt)) : (salt as viem.Hash);

  const txn = {
    to: arachnidAddress,
    data: viem.concatHex([saltHash, initcode]),
  };

  const contractAddress = viem.getCreate2Address({ bytecode: initcode, salt: saltHash, from: arachnidAddress });

  // viem.getAddress will uppercase the address properly for checksum purposes
  return [txn, viem.getAddress(contractAddress)];
}
