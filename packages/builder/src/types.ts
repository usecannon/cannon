import { ethers } from 'ethers';

import { JsonFragment } from '@ethersproject/abi';

import _ from 'lodash';

import type { RawChainDefinition } from './actions';
import { CannonWrapperGenericProvider } from './error/provider';

export type OptionTypesTs = string | number | boolean;

// loosely based on the hardhat `Artifact` type
export type ContractArtifact = {
  contractName: string;
  sourceName: string;
  abi: JsonFragment[];
  bytecode: string;
  deployedBytecode: string;
  linkReferences: {
    [fileName: string]: {
      [contractName: string]: {
        start: number;
        length: number;
      }[];
    };
  };
  source?: {
    solcVersion: string;
    input: string;
  };
};

export type ContractData = {
  address: string;
  abi: JsonFragment[];
  constructorArgs?: any[]; // only needed for external verification
  linkedLibraries?: { [sourceName: string]: { [libName: string]: string } }; // only needed for external verification
  // only should be supplied when generated solidity as a single file
  sourceCode?: string;
  deployTxnHash: string;
  contractName: string;
  sourceName: string;
  deployedOn: string;
  highlight?: boolean;
  gasUsed: number;
  gasCost: string;
};

export type ContractMap = {
  [label: string]: ContractData;
};

export type TransactionMap = {
  [label: string]: {
    hash: string;
    events: EventMap;
    deployedOn: string;
    gasUsed: number;
    gasCost: string;
    signer: string;
  };
};

export type EventMap = {
  [name: string]: {
    args: string[];
  }[];
};

export interface PreChainBuilderContext {
  chainId: number;

  package: any;

  timestamp: string;
}

export interface ChainBuilderContext extends PreChainBuilderContext {
  settings: ChainBuilderOptions;

  contracts: ContractMap;

  txns: TransactionMap;

  extras: { [label: string]: string };

  imports: BundledChainBuilderOutputs;
}

export type ChainBuilderContextWithHelpers = ChainBuilderContext & typeof ethers.utils & typeof ethers.constants;

export type BuildOptions = { [val: string]: OptionTypesTs };

export type StorageMode = 'all' | 'metadata' | 'none';

export interface ChainBuilderRuntimeInfo {
  // Interface to which all transactions should be sent and all state queried
  provider: CannonWrapperGenericProvider;

  // chainID to interact with
  chainId: number;

  // returns the signer associated with the given address. Reverts if the signer is not found or cannot be populated.
  getSigner: (addr: string) => Promise<ethers.Signer>;

  // returns a signer which should be used for sending the specified transaction.
  getDefaultSigner?: (txn: ethers.providers.TransactionRequest, salt?: string) => Promise<ethers.Signer>;

  // returns contract information from the specified artifact name.
  getArtifact?: (name: string) => Promise<ContractArtifact>;

  // Should record snapshots?
  snapshots: boolean;

  // Should gracefully continue after failures and return a partial release?
  allowPartialDeploy: boolean;

  // Should publish contract sources along with bytecode?
  publicSourceCode?: boolean;

  // Gas price to use for transactions
  gasPrice?: string;

  // Base and Priority gas fee to use for transactions - EIP1559
  gasFee?: string;
  priorityGasFee?: string;
}

export interface PackageState {
  name: string;
  version: string;
  currentLabel: string;
}

export type BundledOutput = { url: string; tags?: string[]; preset?: string } & ChainArtifacts;

export interface BundledChainBuilderOutputs {
  [module: string]: BundledOutput;
}

export type ChainArtifacts = Partial<Pick<ChainBuilderContext, 'imports' | 'contracts' | 'txns' | 'extras'>>;

export interface ChainBuilderOptions {
  [key: string]: OptionTypesTs;
}

/**
 * The deployment info is the main output of the cannon build process, and what is ultimately the blob referenced by the registry when pulling a package.
 * It contains all the information
 * needed to interface with a deployment generated by cannon.
 */
export type DeploymentInfo = {
  // used to identify that cannon created an artifact on IPFS
  generator: `cannon ${string}`;

  // the time at which this deployment was generated
  timestamp: number;

  // contents of cannonfile.toml used for this build in raw json form
  // if not included, defaults to the chain definition at the DeploymentManifest instead
  def: RawChainDefinition;

  // setting overrides used to build this chain
  options: ChainBuilderOptions;

  // defines whether this deployment has been fully completed or only partially or completely unbuilt
  status?: 'complete' | 'partial' | 'none';

  // the result of all the build steps for the last build
  state: DeploymentState;

  // additional package information. could be `package.json` file from a hardhat project, for example.
  meta: any;

  // ipfs hash additional required files for possible build
  miscUrl: string;

  // EVM chain which this deployment is for
  chainId?: number;
};

export type DeploymentManifest = {
  // contents of cannonfile.toml stringified
  def: RawChainDefinition;

  // npm style package.json for the project being uploaded
  npmPackage: any;

  // tag of the package which was used as the base for this package
  upgradeFrom?: string;

  // archive which contains miscellaneus dependencies ex. documentation pages, contracts, etc.
  misc: {
    ipfsHash: string;
  };

  deploys: {
    [chainId: string]: {
      [preset: string]: {
        hash: string;
      };
    };
  };
};

/**
 * After executing a build step, this object is recorded to the DeploymentInfo for future reference.
 */
export type StepState = {
  // The BUILD_VERSION when the step was built
  version: number;

  // A md5sum of the step inputs. Used to determine if the step should be rebuilt on upgrades.
  hash: string | null;

  // Once the step completes, the current state of the deployment artifacts is recorded
  artifacts: ChainArtifacts;

  // If this is a cannon network build, the full dump of the chain blob is recorded
  chainDump?: string; // only included if cannon network build
};

export type DeploymentState = { [label: string]: StepState };

export function combineCtx(ctxs: ChainBuilderContext[]): ChainBuilderContext {
  const ctx = _.clone(ctxs[0]);

  ctx.timestamp = Math.floor(Date.now() / 1000).toString(); //(await this.provider.getBlock(await this.provider.getBlockNumber())).timestamp.toString();

  // merge all blockchain outputs
  for (const additionalCtx of ctxs.slice(1)) {
    ctx.contracts = { ...ctx.contracts, ...additionalCtx.contracts };
    ctx.txns = { ...ctx.txns, ...additionalCtx.txns };
    ctx.imports = { ...ctx.imports, ...additionalCtx.imports };
    ctx.extras = { ...ctx.extras, ...additionalCtx.extras };
  }

  return ctx;
}
